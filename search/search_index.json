{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to complex analysis course \u00b6 This page is dedicated to the course of complex analysis taught in the university department of mathematics, Tilka Manjhi Bhagalpur University, Bhagalpur. Syllabus \u00b6 Contour Integration Cauchy Integral Forumula and Related Theorems Power and Laurents Series Sigularites Rouches theorem Course Objectives \u00b6 The course Complex Analysis focussed on the study of properties of complex functions. This is the second course on complex analysis in TMBU, Bhagalpur. The first course mainly introduce the concept of differentiability and analyticity in complex domains. Here we will discuss the integration in the sense of complex functions. Understand contour integration Apply Cauchy integral formula Import results based on CIF Ability to represent complex function as Power and Laurents series Understand different type of singularity Finding the integraton along closed contour References \u00b6 Foundations Of Complex Analysis by S. Ponnusamy Complex Variable: Schaum's Outlines Series Routine \u00b6 Weekday 1 st Period 2 nd Period 3 rd Period 4 th Period 5 th Period 6 th Period MON CA TUE CA WED CA THR CA FRI CA SAT CA Instructor \u00b6 Sandeep Suman, Assistant Professor, TMBU, Bhagalpur","title":"Home"},{"location":"#welcome-to-complex-analysis-course","text":"This page is dedicated to the course of complex analysis taught in the university department of mathematics, Tilka Manjhi Bhagalpur University, Bhagalpur.","title":"Welcome to complex analysis course"},{"location":"#syllabus","text":"Contour Integration Cauchy Integral Forumula and Related Theorems Power and Laurents Series Sigularites Rouches theorem","title":"Syllabus"},{"location":"#course-objectives","text":"The course Complex Analysis focussed on the study of properties of complex functions. This is the second course on complex analysis in TMBU, Bhagalpur. The first course mainly introduce the concept of differentiability and analyticity in complex domains. Here we will discuss the integration in the sense of complex functions. Understand contour integration Apply Cauchy integral formula Import results based on CIF Ability to represent complex function as Power and Laurents series Understand different type of singularity Finding the integraton along closed contour","title":"Course Objectives"},{"location":"#references","text":"Foundations Of Complex Analysis by S. Ponnusamy Complex Variable: Schaum's Outlines Series","title":"References"},{"location":"#routine","text":"Weekday 1 st Period 2 nd Period 3 rd Period 4 th Period 5 th Period 6 th Period MON CA TUE CA WED CA THR CA FRI CA SAT CA","title":"Routine"},{"location":"#instructor","text":"Sandeep Suman, Assistant Professor, TMBU, Bhagalpur","title":"Instructor"},{"location":"Function/","text":"% matplotlib inline % config InlineBackend . figure_format = 'svg' import numpy as np import matplotlib.pyplot as plt import sympy as sp sp . init_printing () After learning about complex numbers, now we are in position to learn about functions that map complex numbers to complex number, i.e., f: \\mathbb{C} \\to \\mathbb{C} . If z=x+iy , then f can be written as \\begin{align} f(z=x+iy) &= u(x,y)+iv(x,y) \\end{align} Where u,v:\\mathbb{R}^2 \\to \\mathbb{R} , u is called the real part and v is called the imaginary part of a complex valued funcion f . x , y , z = sp . symbols ( \"x y z\" ) z = x + 1j * y f = sp . Function ( \"f\" ) f = z ** 2 # Lambda(z, z**2) sp . collect ( f . expand (), 1j ) x^{2} + 2.0 i x y - 1.0 y^{2} from numpy import exp , arange from pylab import meshgrid , cm , imshow , contour , clabel , colorbar , axis , title , subplot , show , figure # the function that I'm going to plot def z_real ( x , y ): return ( x ** 2 - y ** 2 ) def z_imag ( x , y ): return 2 * x * y x = arange ( - 3.0 , 3.0 , 0.05 ) y = arange ( - 3.0 , 3.0 , 0.05 ) X , Y = meshgrid ( x , y ) # grid of point Z_real = z_real ( X , Y ) # evaluation of the function on the grid Z_imag = z_imag ( X , Y ) figure ( figsize = ( 19 , 7 )) subplot ( 1 , 2 , 1 ) im = imshow ( Z_real , cmap = cm . RdBu ) # drawing the function # adding the Contour lines with labels cset = contour ( Z_real , arange ( - 1 , 1.5 , 0.2 ), linewidths = 2 , cmap = cm . Set2 ) clabel ( cset , inline = True , fmt = ' %1.1f ' , fontsize = 10 ) colorbar ( im ) # adding the colobar on the right # latex fashion title title ( '$Re(z)=x^2-y^2$' ) subplot ( 1 , 2 , 2 ) im = imshow ( Z_imag , cmap = cm . RdBu ) # drawing the function # adding the Contour lines with labels cset = contour ( Z_imag , arange ( - 1 , 1.5 , 0.2 ), linewidths = 2 , cmap = cm . Set2 ) clabel ( cset , inline = True , fmt = ' %1.1f ' , fontsize = 10 ) colorbar ( im ) # adding the colobar on the right # latex fashion title title ( '$Re(z)=2xy$' ) show () Now we try to visualize some of the functions in complex domain. Visualizing complex functions are not easy because it require 4- dimensional space to plot a complex functions, and most of us can't visualize 4- dimensional space. Other way is to look at the image different shapes of complex plane under these mappings. Here we look at the image of a square region [1,3]\\times[1,3] under some common mapping. def fun_plot ( f ): u = np . linspace ( 0 , 3 , 80 ) v = np . linspace ( 0 , 3 , 80 ) uu , vv = np . meshgrid ( u , v ) z0 = uu + 1j * vv z = f ( z0 ) T = np . arctan2 ( uu , vv ) plt . scatter ( np . real ( z ), np . imag ( z ), c = T , s = 10 , lw = 0 ) plt . xlabel ( 'Re(z)' ) plt . ylabel ( 'Im(z)' ) plt . grid ( True ) plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ) plt . title ( 'Original Square' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z * ( 2 + 3 * 1j )) plt . title ( '$f(z)=(2+3i)z$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ** 2 ) plt . title ( '$f(z)=z^2$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 3 ) plt . title ( '$f(z)=z^3$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : z ** 4 ) plt . title ( '$f(z)=z^4$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : z ** 5 ) plt . title ( '$f(z)=z^5$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( lambda z : 1 / ( z + 1 )) plt . title ( '$f(z)=1/(1+z)$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : 1 / ( z + 1 ) ** 2 ) plt . title ( '$f(z)=1/(1+z)^2$' ) plt . gray plt . show () from numpy import sin , cos , tan , exp , log plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( sin ) plt . title ( '$f(z)=\\sin \\,z$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( cos ) plt . title ( '$f(z)=\\cos \\,z$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( tan ) plt . title ( '$f(z)=tan \\,z$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : 1 / tan ( z + 1 )) plt . title ( '$f(z)=\\cot \\,(z+1)$' ) plt . gray plt . show () plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) fun_plot ( exp ) plt . title ( '$f(z)=e^z$' ) plt . subplot ( 1 , 2 , 2 ) fun_plot ( lambda z : log ( z + 1 )) plt . title ( '$f(z)=\\log(z+1)$' ) plt . gray plt . show ()","title":"Function"},{"location":"Integration/","text":"from sympy import * init_printing () import sympy.vector as sv x , y , z , t = symbols ( 'x y z t' ) R = sv . CoordSys3D ( 'R' ) def v ( x , y , z ): # vector field as a function of scalar variables x,y,z return x * y * R . i + 2 * y * z * R . j + 3 * x * z * R . k def voft ( l ): # vector field along path l as a function of t x , y , z = ( l . dot ( R . i ), l . dot ( R . j ), l . dot ( R . k )) # x,y,z as functions of t return v ( x , y , z ) def li ( l , v ): # dl/dt dl = diff ( l , t ) return integrate ( voft ( l ) . dot ( dl ),( t , 0 , 1 )) l1 = 2 * t * R . j l2 = 2 * ( 1 - t ) * R . j + 2 * t * R . k l3 = 2 * ( 1 - t ) * R . k li ( l1 , v ), li ( l2 , v ), li ( l3 , v ) \\left ( 0, \\quad - \\frac{8}{3}, \\quad 0\\right ) l1 , l2 , l3 \\left ( (2 t)\\mathbf{\\hat{j}_{R}}, \\quad (- 2 t + 2)\\mathbf{\\hat{j}_{R}} + (2 t)\\mathbf{\\hat{k}_{R}}, \\quad (- 2 t + 2)\\mathbf{\\hat{k}_{R}}\\right ) dl1 = diff ( l1 , t ) dl2 = diff ( l2 , t ) dl3 = diff ( l3 , t ) dl1 , dl2 , dl3 \\left ( (2)\\mathbf{\\hat{j}_{R}}, \\quad (-2)\\mathbf{\\hat{j}_{R}} + (2)\\mathbf{\\hat{k}_{R}}, \\quad (-2)\\mathbf{\\hat{k}_{R}}\\right ) voft ( l1 ), voft ( l2 ), voft ( l3 ) \\left ( \\mathbf{\\hat{0}}, \\quad (2 t \\left(- 4 t + 4\\right))\\mathbf{\\hat{j}_{R}}, \\quad \\mathbf{\\hat{0}}\\right ) voft ( l1 ) . dot ( l1 ), voft ( l2 ) . dot ( l2 ), voft ( l3 ) . dot ( l3 ) \\left ( 0, \\quad 2 t \\left(- 4 t + 4\\right) \\left(- 2 t + 2\\right), \\quad 0\\right ) integrate ( voft ( l2 ) . dot ( dl2 ),( t , 0 , 1 )) - \\frac{8}{3} A contour is a finite collection of paths joined end to end. A path can be represented as a continuous function form an closed iterval to \\mathbb{C} as follows \\gamma: [a~ b]\\subset \\mathbb{R} \\to \\mathbb{C}; \\quad \\gamma = \\gamma(t) Then the integration of any complex function along this path is is given by \\int_\\gamma f(z)dz = \\int_a^b f(t)~\\gamma'(t)~dt = \\sum_{i=1}^n f(t_i) \\left[\\gamma(t_i)-\\gamma(t_{i-1})\\right] Question: Find the integration of f(z)=z^2 along the parabolic path from 0 to 1 . Answer: In order to find the integration we have to find to parametrize the curve as \\gamma(t)=t+t^2i , t\\in [0,1] . % matplotlib inline import numpy as np from matplotlib import pyplot as plt x , y , t = symbols ( \"x y t\" ) def \u03b3 ( t ): return t + t ** 2 * 1j def f ( z ): return z * z # arr = np.linspace(0, 1, 10) # cnums = [\u03b3(t) for t in arr] # imgs = [f(z) for z in cnums] arr = np . linspace ( 0 , 1 , 10 ) # Y = np.linspace(0, 1, 10) X , Y = np . meshgrid ( arr , arr ) U = X ** 2 - Y ** 2 V = 2 * X * Y plt . quiver ( X , Y , U , V , edgecolor = 'k' , facecolor = 'None' , linewidth =. 5 ) cnums = np . array ( list ( map ( \u03b3 , arr ))) imgs = np . array ( list ( map ( f , cnums ))) X_0 = list ( map ( lambda z : z . real , cnums )) Y_0 = list ( map ( lambda z : z . imag , cnums )) U_0 = list ( map ( lambda z : z . real , imgs )) V_0 = list ( map ( lambda z : z . imag , imgs )) plt . plot ( X_0 , Y_0 , color = 'blue' ) plt . scatter ( X_0 , Y_0 , color = 'red' ) plt . quiver ( X_0 , Y_0 , U_0 , V_0 ) plt . show () # [(f(x+1j*y).real, f(x+1j*y).imag) for x in X for y in Y ] Here we will do the numerical computation \u0394 t = cnums [ 1 :] - cnums [: - 1 ] np . dot ( imgs [ 1 :], \u0394 t ) (-0.6818686799806022+0.675438053988273j) Now we do the same computation using integration integrate ( f ( \u03b3 ( t )) * diff ( \u03b3 ( t ), t ),( t , 0 , 1 )) -0.666666666666667 + 0.666666666666667 i import numpy as np from matplotlib import pyplot as plt from matplotlib import animation X , Y = np . mgrid [: 2 * np . pi : 10j ,: 2 * np . pi : 5j ] U = np . cos ( X ) V = np . sin ( Y ) fig , ax = plt . subplots ( 1 , 1 ) Q = ax . quiver ( X , Y , U , V , pivot = 'mid' , color = 'r' , units = 'inches' ) ax . set_xlim ( - 1 , 7 ) ax . set_ylim ( - 1 , 7 ) def update_quiver ( num , Q , X , Y ): \"\"\"updates the horizontal and vertical vector components by a fixed increment on each frame \"\"\" U = np . cos ( X + num * 0.1 ) V = np . sin ( Y + num * 0.1 ) Q . set_UVC ( U , V ) return Q # you need to set blit=False, or the first set of arrows never gets # cleared on subsequent frames anim = animation . FuncAnimation ( fig , update_quiver , fargs = ( Q , X , Y ), interval = 50 , blit = False ) fig . tight_layout () plt . show () import plotly.plotly as py from plotly.grid_objs import Grid , Column import time column_1 = Column ([ 0.9 , 1.1 ], 'x' ) column_2 = Column ([ 1.0 , 1.0 ], 'y' ) column_3 = Column ([ 0.8 , 1.2 ], 'x2' ) column_4 = Column ([ 1.2 , 0.8 ], 'y2' ) column_5 = Column ([ 0.7 , 1.3 ], 'x3' ) column_6 = Column ([ 0.7 , 1.3 ], 'y3' ) column_7 = Column ([ 0.6 , 1.4 ], 'x4' ) column_8 = Column ([ 1.5 , 0.5 ], 'y4' ) column_9 = Column ([ 0.4 , 1.6 ], 'x5' ) column_10 = Column ([ 1.2 , 0.8 ], 'y5' ) grid = Grid ([ column_1 , column_2 , column_3 , column_4 , column_5 , column_6 , column_7 , column_8 , column_9 , column_10 ]) py . grid_ops . upload ( grid , 'points_changing_size_grid' + str ( time . time ()), auto_open = False ) # create figure figure = { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x' ), 'ysrc' : grid . get_column_reference ( 'y' ), 'mode' : 'markers' , 'marker' : { 'color' : '#48186a' , 'size' : 10 } } ], 'layout' : { 'title' : 'Growing Circles' , 'xaxis' : { 'range' : [ 0 , 2 ], 'autorange' : False }, 'yaxis' : { 'range' : [ 0 , 2 ], 'autorange' : False }, 'updatemenus' : [{ 'buttons' : [ { 'args' : [ None ], 'label' : 'Play' , 'method' : 'animate' } ], 'pad' : { 'r' : 10 , 't' : 87 }, 'showactive' : False , 'type' : 'buttons' }]}, 'frames' : [ { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x2' ), 'ysrc' : grid . get_column_reference ( 'y2' ), 'mode' : 'markers' , 'marker' : { 'color' : '#3b528b' , 'size' : 25 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x3' ), 'ysrc' : grid . get_column_reference ( 'y3' ), 'mode' : 'markers' , 'marker' : { 'color' : '#26828e' , 'size' : 50 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x4' ), 'ysrc' : grid . get_column_reference ( 'y4' ), 'mode' : 'markers' , 'marker' : { 'color' : '#5ec962' , 'size' : 80 } } ] }, { 'data' : [ { 'xsrc' : grid . get_column_reference ( 'x5' ), 'ysrc' : grid . get_column_reference ( 'y5' ), 'mode' : 'markers' , 'marker' : { 'color' : '#d8e219' , 'size' : 100 } } ] } ] } py . icreate_animations ( figure , 'points_changing_size' + str ( time . time ())) import plotly plotly . __version__ '3.7.0'","title":"Definition"},{"location":"Introduction/","text":"In this section we will define complex numbers as an extension of \\mathbb{R} as the following \\mathbb{C} \\cong \\mathbb{R}[x] / \\langle x^2+1 \\rangle = \\{a+bx+\\langle x^2+1 \\rangle\\ | ~ a,b \\in \\mathbb{R} \\} from sympy import * init_printing () a , b , c , d = symbols ( \"a b c d\" ) x , y = symbols ( \"x y\" ) Algebra of Complex Number \u00b6 Addition of two complex numbers are done as follows ad = ( a + b * x ) + ( c + d * x ) Eq ( ad , collect ( ad , x )) a + b x + c + d x = a + c + x \\left(b + d\\right) Multiplication is done as follows mul = ( a + b * x ) * ( c + d * x ) Eq ( mul , expand ( mul )) \\left(a + b x\\right) \\left(c + d x\\right) = a c + a d x + b c x + b d x^{2} irr = x ** 2 + 1 quo , rem = pdiv ( mul , irr ) collect ( rem , x ) a c - b d + x \\left(a d + b c\\right)","title":"Definition"},{"location":"Introduction/#algebra-of-complex-number","text":"Addition of two complex numbers are done as follows ad = ( a + b * x ) + ( c + d * x ) Eq ( ad , collect ( ad , x )) a + b x + c + d x = a + c + x \\left(b + d\\right) Multiplication is done as follows mul = ( a + b * x ) * ( c + d * x ) Eq ( mul , expand ( mul )) \\left(a + b x\\right) \\left(c + d x\\right) = a c + a d x + b c x + b d x^{2} irr = x ** 2 + 1 quo , rem = pdiv ( mul , irr ) collect ( rem , x ) a c - b d + x \\left(a d + b c\\right)","title":"Algebra of Complex Number"},{"location":"Plotting/","text":"A complex numbers x+iy can be plotted in cartesian coordinate as the point (x,y) . This plane is called Argand plane. % matplotlib inline % config InlineBackend . figure_format = 'svg' from utility import argand import matplotlib.pyplot as plt argand ( 1 + 10 * 1j , vector = True ) plt . text ( 1 , 10 , '$1+10i$' , horizontalalignment = 'right' , verticalalignment = 'bottom' ) x1 , x2 , y1 , y2 = plt . axis () plt . axis (( x1 , x2 , y1 , 11 )) plt . show () cnums = np . arange ( 5 ) + 1j * np . arange ( 6 , 11 ) [ argand ( x , vector = True ) for x in cnums ] plt . show () Addition and Substraction \u00b6 Addition and substraction of complex numbers in Argand plane are similar to the vector addition and multiplication. [ argand ( x , vector = True ) for x in [ 1 + 10j , 10 + 1j , 1 + 10j + 10 + 1j ]] plt . text ( 1 , 10.1 , '$z_1$' , horizontalalignment = 'left' , verticalalignment = 'bottom' ) plt . text ( 10.5 , 0.9 , '$z_2$' , horizontalalignment = 'right' , verticalalignment = 'bottom' ) plt . text ( 10.9 , 11 , '$z_1+z_2$' , horizontalalignment = 'right' , verticalalignment = 'bottom' ) x1 , x2 , y1 , y2 = plt . axis () plt . axis (( x1 , x2 , y1 , 12 )) plt . show () [ argand ( x , vector = True ) for x in [ 1 + 10j , 10 + 1j , - ( 10 + 1j ), 1 + 10j - ( 10 + 1j )]] plt . show () Multiplication in Complex Numbers \u00b6 If we multiply two complex number z_1=r_1e^{i\\theta_1} and z_2=r_2e^{i\\theta_2} , then we get z_1\\cdot z_2 = r_1\\cdot r_2 e^{i (\\theta_1 + \\theta_2)} Hence in polar coordinate, the magnitude will get multiplies while angle will get added. [ argand ( x , vector = True ) for x in [ 2 + 1j , 1 + 2j , ( 1 + 1j ) * ( 1 + 2j )]] plt . show () [ argand ( x , vector = True ) for x in [ 2 + 1j , 1 + 2j , ( 1 + 1j ) / ( 1 + 2j )]] plt . show () Sequence and Series in Complex Numbers \u00b6 Similar to real sequance, a complex sequence in simple a function f: \\mathbb{N} \\to \\mathbb{C} . plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) [ argand ((( 1 + 1j ) / 2 ) ** n ) for n in range ( 15 )] plt . title ( '$z_n = (\\dfrac{1+i}{2} )^n$' ) plt . subplot ( 1 , 2 , 2 ) z = ( 1 + 2j ) / 4 [ argand ( z ** n ) for n in range ( 15 )] plt . show () Example of a diverging sequence. [ argand (( 1 + 1j ) ** n ) for n in range ( 10 )]; plt . show ()","title":"Plotting"},{"location":"Plotting/#addition-and-substraction","text":"Addition and substraction of complex numbers in Argand plane are similar to the vector addition and multiplication. [ argand ( x , vector = True ) for x in [ 1 + 10j , 10 + 1j , 1 + 10j + 10 + 1j ]] plt . text ( 1 , 10.1 , '$z_1$' , horizontalalignment = 'left' , verticalalignment = 'bottom' ) plt . text ( 10.5 , 0.9 , '$z_2$' , horizontalalignment = 'right' , verticalalignment = 'bottom' ) plt . text ( 10.9 , 11 , '$z_1+z_2$' , horizontalalignment = 'right' , verticalalignment = 'bottom' ) x1 , x2 , y1 , y2 = plt . axis () plt . axis (( x1 , x2 , y1 , 12 )) plt . show () [ argand ( x , vector = True ) for x in [ 1 + 10j , 10 + 1j , - ( 10 + 1j ), 1 + 10j - ( 10 + 1j )]] plt . show ()","title":"Addition and Substraction"},{"location":"Plotting/#multiplication-in-complex-numbers","text":"If we multiply two complex number z_1=r_1e^{i\\theta_1} and z_2=r_2e^{i\\theta_2} , then we get z_1\\cdot z_2 = r_1\\cdot r_2 e^{i (\\theta_1 + \\theta_2)} Hence in polar coordinate, the magnitude will get multiplies while angle will get added. [ argand ( x , vector = True ) for x in [ 2 + 1j , 1 + 2j , ( 1 + 1j ) * ( 1 + 2j )]] plt . show () [ argand ( x , vector = True ) for x in [ 2 + 1j , 1 + 2j , ( 1 + 1j ) / ( 1 + 2j )]] plt . show ()","title":"Multiplication in Complex Numbers"},{"location":"Plotting/#sequence-and-series-in-complex-numbers","text":"Similar to real sequance, a complex sequence in simple a function f: \\mathbb{N} \\to \\mathbb{C} . plt . figure ( figsize = ( 14 , 6 )) plt . subplot ( 1 , 2 , 1 ) [ argand ((( 1 + 1j ) / 2 ) ** n ) for n in range ( 15 )] plt . title ( '$z_n = (\\dfrac{1+i}{2} )^n$' ) plt . subplot ( 1 , 2 , 2 ) z = ( 1 + 2j ) / 4 [ argand ( z ** n ) for n in range ( 15 )] plt . show () Example of a diverging sequence. [ argand (( 1 + 1j ) ** n ) for n in range ( 10 )]; plt . show ()","title":"Sequence and Series in Complex Numbers"},{"location":"assignments/","text":"Assignments \u00b6 As a part of continuous assesment you have to submit the assignment S. No. Donwload Link Due Date 1 Download 15/05/2019 2 3 4 5","title":"Assignments"},{"location":"assignments/#assignments","text":"As a part of continuous assesment you have to submit the assignment S. No. Donwload Link Due Date 1 Download 15/05/2019 2 3 4 5","title":"Assignments"},{"location":"exam/","text":"Exams \u00b6 The course has two exams one is internal of 15 marks, while the other is final worth 70 marks. Rest marks are part of continuous assesment that belongs to attendence, seminar and assignments. Internal Exam \u00b6 Final Exam \u00b6 Final exam divided in three groups. The questions are organized in three groups as follows: Group No of Questions Marks per Question Total A 10/10 2 20 B 04/05 5 20 C 03/05 10 30","title":"Exam"},{"location":"exam/#exams","text":"The course has two exams one is internal of 15 marks, while the other is final worth 70 marks. Rest marks are part of continuous assesment that belongs to attendence, seminar and assignments.","title":"Exams"},{"location":"exam/#internal-exam","text":"","title":"Internal Exam"},{"location":"exam/#final-exam","text":"Final exam divided in three groups. The questions are organized in three groups as follows: Group No of Questions Marks per Question Total A 10/10 2 20 B 04/05 5 20 C 03/05 10 30","title":"Final Exam"}]}